[require]
GL_ARB_vertex_program

[vertex program]
!!ARBvp1.0
	TEMP	R0, R1;
	TEMP	fail, pass;
	ADDRESS	A0;

	# program.env[0] is the base index for indirections
	# program.env[1..4] are the operands for the instructions
	# program.env[5..${5 + len(programs) - 1}] are the expected values
	# program.env[${5 + len(programs)}..${5 + 2 * len(programs) - 1}] are the tolerance values
	PARAM	c[] = { program.env[0..4] };
	PARAM	expect[] = { program.env[5..${5 + len(programs) - 1}] };
	PARAM	tol[] = { program.env[${5 + len(programs)}..${5 + 2 * len(programs) - 1}] };
	ARL	A0.x, c[0].x;

% for i in range(len(programs)):
	# Combination ${i}
${programs[i]}
% if i == 0:
	# fail = any(greaterThanEqual(abs(value - expect), tolerance));
% elif i == 1:
	# fail = fail || any(greaterThanEqual(abs(value - expect), tolerance));
% endif
	SUB	R0, R0, expect[${i}];
	ABS	R0, R0;
	SGE	R0, R0, tol[${i}];
% if i == 0:
	DP4	fail.x, R0, R0;
% else:
	DP4	R0.x, R0, R0;
	ADD	fail.x, fail.x, R0.x;
% endif

% endfor
	MIN	fail.x, fail.x, {1.0}.x;	# Clamp to [0,1]
	SUB	pass.x, {1.0}.x, fail.x;	# Logical not
	MUL	R1, pass.x, {0.0, 1.0, 0.0, 1.0};
	MAD	result.color, fail.x, {1.0, 0.0, 0.0, 1.0}, R1;
	MOV	result.position, vertex.position;
	END

[test]
clear color 0.5 0.5 0.5 0.5
clear
% for [env, expected, not_expected, x, y, w, h] in test_vectors:

% for i in range(len(env)):
parameter env_vp ${i} (${env[i][0]}, ${env[i][1]}, ${env[i][2]}, ${env[i][3]})
% endfor
# Expected values
% for i in range(len(expected)):
parameter env_vp ${i + 5} (${expected[i][0]}, ${expected[i][1]}, ${expected[i][2]}, ${expected[i][3]})
% endfor
# Tolerance values
% for i in range(len(expected)):
parameter env_vp ${i + 5 + len(expected)} (${max(1e-5, 1e-6 * expected[i][0])}, ${max(1e-5, 1e-6 * expected[i][1])}, ${max(1e-5, 1e-6 * expected[i][2])}, ${max(1e-5, 1e-6 * expected[i][3])})
% endfor
# "Not expected" value
parameter env_vp ${5 + 2 * len(expected)} (${not_expected}, 0, 1, 0)
draw rect ${x} ${y} ${w} ${h}
% endfor

% for [env, expected, not_expected, x, y, w, h] in test_vectors:
relative probe rgb (${.5 * (x + w * .5) + .5}, ${.5 * (y + h * .5) + .5}) (0, 1, 0)
% endfor
