[require]
GL_ARB_fragment_program

[fragment program]
!!ARBfp1.0
	TEMP	R0, R1;
	TEMP	fail, pass;

	# program.env[0..2] are the operands for the instructions
	# program.env[3..${3 + len(programs) - 1}] are the expected values
	# program.env[${3 + len(programs)}..${3 + 2 * len(programs) - 1}] are the tolerance values
	# program.env[${3 + 2 * len(programs)}] is { never expected value, 0, 1, 0 }

% for i in range(len(programs)):
	# Combination ${i}
${programs[i]}
% if i == 0:
	# fail = any(greaterThanEqual(abs(value - expect), tolerance));
% elif i == 1:
	# fail = fail || any(greaterThanEqual(abs(value - expect), tolerance));
% endif
	SUB	R0, R0, program.env[${3 + i}];
	ABS	R0, R0;
	SGE	R0, R0, program.env[${3 + len(programs) + i}];
% if i == 0:
	DP4	fail.x, R0, R0;
% else:
	DP4	R0.x, R0, R0;
	ADD_SAT	fail.x, fail.x, R0.x;
% endif

% endfor
	SUB	pass.x, {1.0}.x, fail.x;	# Logical not
	MUL	R1, pass.x, {0.0, 1.0, 0.0, 1.0};
	MAD	result.color, fail.x, {1.0, 0.0, 0.0, 1.0}, R1;
	END

[test]
clear color 0.5 0.5 0.5 0.5
clear
% for [env, expected, not_expected, x, y, w, h] in test_vectors:

% for i in range(len(env)):
parameter env_fp ${i} (${env[i][0]}, ${env[i][1]}, ${env[i][2]}, ${env[i][3]})
% endfor
# Expected values
% for i in range(len(expected)):
parameter env_fp ${i + 3} (${expected[i][0]}, ${expected[i][1]}, ${expected[i][2]}, ${expected[i][3]})
% endfor
# Tolerance values
% for i in range(len(expected)):
parameter env_fp ${i + 3 + len(expected)} (${max(1e-5, 1e-6 * expected[i][0])}, ${max(1e-5, 1e-6 * expected[i][1])}, ${max(1e-5, 1e-6 * expected[i][2])}, ${max(1e-5, 1e-6 * expected[i][3])})
% endfor
# "Not expected" value
parameter env_fp ${3 + 2 * len(expected)} (${not_expected}, 0, 1, 0)
draw rect ${x} ${y} ${w} ${h}
% endfor

% for [env, expected, not_expected, x, y, w, h] in test_vectors:
relative probe rgb (${.5 * (x + w * .5) + .5}, ${.5 * (y + h * .5) + .5}) (0, 1, 0)
% endfor
